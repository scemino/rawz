const std = @import("std");
const assert = std.debug.assert;

pub const GAME_WIDTH = 320;
pub const GAME_HEIGHT = 200;
const GFX_COL_ALPHA = 0x10; // transparent pixel (OR'ed with 0x8)
const GFX_COL_PAGE = 0x11; // buffer 0 pixel
pub const GAME_QUAD_STRIP_MAX_VERTICES = 70;

pub const Format = enum(u2) {
    clut,
    rgb555,
    rgb,
    rgba,
};

const font = [_]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x00, 0x08, 0x3E, 0x48, 0x3C, 0x12, 0x7C, 0x10, 0x00, 0x42, 0xA4, 0x48, 0x10, 0x24, 0x4A, 0x84, 0x00, 0x60, 0x90, 0x90, 0x70, 0x8A, 0x84, 0x7A, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x08, 0x10, 0x10, 0x10, 0x08, 0x06, 0x00, 0xC0, 0x20, 0x10, 0x10, 0x10, 0x20, 0xC0, 0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x28, 0x10, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x78, 0x84, 0x8C, 0x94, 0xA4, 0xC4, 0x78, 0x00, 0x10, 0x30, 0x50, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x78, 0x84, 0x04, 0x08, 0x30, 0x40, 0xFC, 0x00, 0x78, 0x84, 0x04, 0x38, 0x04, 0x84, 0x78, 0x00, 0x08, 0x18, 0x28, 0x48, 0xFC, 0x08, 0x08, 0x00, 0xFC, 0x80, 0xF8, 0x04, 0x04, 0x84, 0x78, 0x00, 0x38, 0x40, 0x80, 0xF8, 0x84, 0x84, 0x78, 0x00, 0xFC, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x78, 0x84, 0x84, 0x78, 0x84, 0x84, 0x78, 0x00, 0x78, 0x84, 0x84, 0x7C, 0x04, 0x08, 0x70, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x10, 0x10, 0x60, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x7C, 0x82, 0x02, 0x0C, 0x10, 0x00, 0x10, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x78, 0x84, 0x84, 0xFC, 0x84, 0x84, 0x84, 0x00, 0xF8, 0x84, 0x84, 0xF8, 0x84, 0x84, 0xF8, 0x00, 0x78, 0x84, 0x80, 0x80, 0x80, 0x84, 0x78, 0x00, 0xF8, 0x84, 0x84, 0x84, 0x84, 0x84, 0xF8, 0x00, 0x7C, 0x40, 0x40, 0x78, 0x40, 0x40, 0x7C, 0x00, 0xFC, 0x80, 0x80, 0xF0, 0x80, 0x80, 0x80, 0x00, 0x7C, 0x80, 0x80, 0x8C, 0x84, 0x84, 0x7C, 0x00, 0x84, 0x84, 0x84, 0xFC, 0x84, 0x84, 0x84, 0x00, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x04, 0x04, 0x04, 0x04, 0x84, 0x84, 0x78, 0x00, 0x8C, 0x90, 0xA0, 0xE0, 0x90, 0x88, 0x84, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFC, 0x00, 0x82, 0xC6, 0xAA, 0x92, 0x82, 0x82, 0x82, 0x00, 0x84, 0xC4, 0xA4, 0x94, 0x8C, 0x84, 0x84, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0xF8, 0x84, 0x84, 0xF8, 0x80, 0x80, 0x80, 0x00, 0x78, 0x84, 0x84, 0x84, 0x84, 0x8C, 0x7C, 0x03, 0xF8, 0x84, 0x84, 0xF8, 0x90, 0x88, 0x84, 0x00, 0x78, 0x84, 0x80, 0x78, 0x04, 0x84, 0x78, 0x00, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0x84, 0x84, 0x84, 0x84, 0x84, 0x48, 0x30, 0x00, 0x82, 0x82, 0x82, 0x82, 0x92, 0xAA, 0xC6, 0x00, 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82, 0x00, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00, 0xFC, 0x04, 0x08, 0x10, 0x20, 0x40, 0xFC, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x38, 0x04, 0x3C, 0x44, 0x3C, 0x00, 0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x78, 0x00, 0x00, 0x00, 0x3C, 0x40, 0x40, 0x40, 0x3C, 0x00, 0x04, 0x04, 0x3C, 0x44, 0x44, 0x44, 0x3C, 0x00, 0x00, 0x00, 0x38, 0x44, 0x7C, 0x40, 0x3C, 0x00, 0x38, 0x44, 0x40, 0x60, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3C, 0x44, 0x44, 0x3C, 0x04, 0x78, 0x40, 0x40, 0x58, 0x64, 0x44, 0x44, 0x44, 0x00, 0x10, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x40, 0x40, 0x46, 0x48, 0x70, 0x48, 0x46, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0xEC, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x00, 0x00, 0x3C, 0x44, 0x44, 0x3C, 0x04, 0x04, 0x00, 0x00, 0x4C, 0x70, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3C, 0x40, 0x38, 0x04, 0x78, 0x00, 0x10, 0x10, 0x3C, 0x10, 0x10, 0x10, 0x0C, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x78, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00, 0x82, 0x82, 0x92, 0xAA, 0xC6, 0x00, 0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x42, 0x22, 0x24, 0x18, 0x08, 0x30, 0x00, 0x00, 0x7C, 0x08, 0x10, 0x20, 0x7C, 0x00, 0x60, 0x90, 0x20, 0x40, 0xF0, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x38, 0x44, 0xBA, 0xA2, 0xBA, 0x44, 0x38, 0x00, 0x38, 0x44, 0x82, 0x82, 0x44, 0x28, 0xEE, 0x00, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA };
pub const GamePoint = struct { x: i16 = 0, y: i16 = 0 };

pub const GameQuadStrip = struct {
    num_vertices: u8 = 0,
    vertices: [GAME_QUAD_STRIP_MAX_VERTICES]GamePoint,
};

const GameFramebuffer = struct {
    buffer: [GAME_WIDTH * GAME_HEIGHT]u8 = [1]u8{0} ** (GAME_WIDTH * GAME_HEIGHT),
};

fb: [GAME_WIDTH * GAME_HEIGHT]u8 = [1]u8{0} ** (GAME_WIDTH * GAME_HEIGHT), // frame buffer: this where is stored the image with indexed color
fbs: [4]GameFramebuffer = [1]GameFramebuffer{.{}} ** 4,
palette: [256]u32 = [1]u32{0} ** 256, // palette containing 16 RGBA colors
draw_page: u2 = 0,
fix_up_palette: bool = false, // redraw all primitives on setPal script call
const Self = @This();

pub fn clearBuffer(self: *Self, page: u2, color: u8) void {
    @memset(self.getPagePtr(page), color);
}

pub fn setPalette(self: *Self, colors: [16]u32) void {
    assert(colors.len <= 16);
    @memcpy(self.palette[0..16], colors[0..16]);
}

pub fn getPagePtr(self: *Self, page: u2) *[GAME_WIDTH * GAME_HEIGHT]u8 {
    return &self.fbs[page].buffer;
}

pub fn setWorkPagePtr(self: *Self, page: u2) void {
    self.draw_page = page;
}

pub fn copyBuffer(self: *Self, dst: u2, src: u2, vscroll: i32) void {
    if (vscroll == 0) {
        @memcpy(self.getPagePtr(dst), self.getPagePtr(src));
    } else if (vscroll >= -199 and vscroll <= 199) {
        const dy = vscroll;
        if (dy < 0) {
            const size: usize = @as(usize, @intCast(GAME_HEIGHT + dy)) * GAME_WIDTH;
            @memcpy(self.getPagePtr(dst)[0..size], self.getPagePtr(src)[@as(usize, @intCast(-dy * GAME_WIDTH))..][0..size]);
        } else {
            const size: usize = @as(usize, @intCast(GAME_HEIGHT - dy)) * GAME_WIDTH;
            @memcpy(self.getPagePtr(dst)[@as(usize, @intCast(dy * GAME_WIDTH))..][0..size], self.getPagePtr(src)[0..size]);
        }
    }
}

pub fn drawBuffer(self: *Self, num: u2) void {
    const src = self.getPagePtr(num);
    @memcpy(self.fb[0..], src[0 .. GAME_WIDTH * GAME_HEIGHT]);
}

pub fn drawStringChar(self: *Self, page: u2, color: u8, c: u8, pt: GamePoint) void {
    self.setWorkPagePtr(page);
    self.drawChar(c, @bitCast(pt.x), @bitCast(pt.y), color);
}

pub fn drawPointPage(self: *Self, page: u2, color: u8, pt: GamePoint) void {
    self.setWorkPagePtr(page);
    self.drawPoint(pt.x, pt.y, color);
}

pub fn drawQuadStrip(self: *Self, buffer: u2, color: u8, qs: *const GameQuadStrip) void {
    self.setWorkPagePtr(buffer);
    self.drawPolygon(color, qs);
}

pub fn drawBitmap(self: *Self, page: u2, data: []const u8, w: u16, h: u16, fmt: Format) void {
    if (fmt == .clut and GAME_WIDTH == w and GAME_HEIGHT == h) {
        @memcpy(self.getPagePtr(page)[0 .. w * h], data);
        return;
    }
    unreachable;
}

fn drawChar(self: *Self, c: u8, x: u16, y: u16, color: u8) void {
    if ((x <= GAME_WIDTH - 8) and (y <= GAME_HEIGHT - 8)) {
        const ft = font[(@as(usize, @intCast(c - 0x20))) * 8 ..];
        const offset = (x + y * GAME_WIDTH);
        for (0..8) |j| {
            const ch = ft[j];
            inline for (0..8) |i| {
                if ((ch & (1 << (7 - i))) != 0) {
                    self.fbs[self.draw_page].buffer[offset + j * GAME_WIDTH + i] = color;
                }
            }
        }
    }
}

fn drawPoint(self: *Self, x: i16, y: i16, color: u8) void {
    const offset = @as(i32, @intCast(y)) * GAME_WIDTH + (@as(i32, @intCast(x)));
    self.fbs[self.draw_page].buffer[@intCast(offset)] = switch (color) {
        GFX_COL_ALPHA => self.fbs[self.draw_page].buffer[@intCast(offset)] | 8,
        GFX_COL_PAGE => self.fbs[0].buffer[@intCast(offset)],
        else => color,
    };
}

fn drawPolygon(self: *Self, color: u8, qs: *const GameQuadStrip) void {
    var i: usize = 0;
    var j: usize = qs.num_vertices - 1;

    var x2: i16 = qs.vertices[i].x;
    var x1: i16 = qs.vertices[j].x;
    var hliney: i16 = @min(qs.vertices[i].y, qs.vertices[j].y);

    i += 1;
    j -= 1;

    const draw_func = switch (color) {
        GFX_COL_PAGE => &drawLineP,
        GFX_COL_ALPHA => &drawLineTrans,
        else => &drawLineN,
    };

    var cpt1: u32 = @as(u32, @intCast(@as(u16, @bitCast(x1)))) << 16;
    var cpt2: u32 = @as(u32, @intCast(@as(u16, @bitCast(x2)))) << 16;

    var num_vertices = qs.num_vertices;
    while (true) {
        num_vertices -= 2;
        if (num_vertices == 0) {
            return;
        }
        var h: u16 = undefined;
        const step1 = calcStep(qs.vertices[j + 1], qs.vertices[j], &h);
        const step2 = calcStep(qs.vertices[i - 1], qs.vertices[i], &h);

        i += 1;
        j -= 1;

        cpt1 = (cpt1 & 0xFFFF0000) | 0x7FFF;
        cpt2 = (cpt2 & 0xFFFF0000) | 0x8000;

        if (h == 0) {
            cpt1 +%= step1;
            cpt2 +%= step2;
        } else {
            for (0..h) |_| {
                if (hliney >= 0) {
                    x1 = @bitCast(@as(u16, @truncate(cpt1 >> 16)));
                    x2 = @bitCast(@as(u16, @truncate(cpt2 >> 16)));
                    if (x1 < GAME_WIDTH and x2 >= 0) {
                        if (x1 < 0) x1 = 0;
                        if (x2 >= GAME_WIDTH) x2 = GAME_WIDTH - 1;
                        draw_func(self, x1, x2, hliney, color);
                    }
                }
                cpt1 +%= step1;
                cpt2 +%= step2;
                hliney += 1;
                if (hliney >= GAME_HEIGHT) return;
            }
        }
    }
}

fn drawLineP(self: *Self, x1: i16, x2: i16, y: i16, _: u8) void {
    if (self.draw_page == 0) {
        return;
    }
    const xmax = @as(i32, @intCast(@max(x1, x2)));
    const xmin = @as(i32, @intCast(@min(x1, x2)));
    const w: i32 = xmax - xmin + 1;
    const offset = (@as(i32, @intCast(y)) * GAME_WIDTH + xmin);
    std.mem.copyForwards(u8, self.fbs[self.draw_page].buffer[@intCast(offset)..][0..@intCast(w)], self.fbs[0].buffer[@intCast(offset)..][0..@intCast(w)]);
}

fn drawLineN(self: *Self, x1: i16, x2: i16, y: i16, color: u8) void {
    const xmax = @as(i32, @intCast(@max(x1, x2)));
    const xmin = @as(i32, @intCast(@min(x1, x2)));
    const w: i32 = xmax - xmin + 1;
    const offset = (@as(i32, @intCast(y)) * GAME_WIDTH + xmin);
    @memset(self.fbs[self.draw_page].buffer[@intCast(offset)..@intCast(offset + w)], color);
}

fn drawLineTrans(self: *Self, x1: i16, x2: i16, y: i16, _: u8) void {
    const xmax = @max(x1, x2);
    const xmin = @min(x1, x2);
    const w: usize = @intCast(xmax - xmin + 1);
    const offset: usize = (@as(usize, @intCast(y)) * GAME_WIDTH + @as(usize, @intCast(xmin)));
    for (0..w) |i| {
        self.fbs[self.draw_page].buffer[offset + i] |= 8;
    }
}

fn calcStep(p1: GamePoint, p2: GamePoint, dy: *u16) u32 {
    dy.* = @intCast(p2.y - p1.y);
    const delta: u16 = if (dy.* <= 1) 1 else dy.*;
    return @bitCast(@as(i32, @intCast(p2.x - p1.x)) * @as(i32, @intCast(0x4000 / delta)) << 2);
}
